// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Nact = require("reason-nact/src/Nact.bs.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");
var NactCron_Expression = require("./NactCron_Expression.bs.js");
var NactCron_Scheduling = require("./NactCron_Scheduling.bs.js");

function currentMinute(param) {
  return ((Date.now() | 0) / 1000 | 0) / 60 | 0;
}

function dateFromMinute(minute) {
  return new Date(Math.imul(Math.imul(minute, 1000), 60));
}

function $$setInterval$1(state, ctx) {
  if (state.interval !== undefined) {
    return state;
  } else {
    return {
            scheduleState: state.scheduleState,
            interval: Caml_option.some(setInterval((function (param) {
                        return Nact.Operators.$less$neg$less(ctx.self, "DispatchPendingJobs");
                      }), 30000)),
            lastMinute: state.lastMinute
          };
  }
}

function promiseReduce(arr, initialValue, f) {
  return Belt_Array.reduce(arr, Promise.resolve(initialValue), (function (prev, value) {
                return prev.then(function (prev) {
                            return Curry._2(f, prev, value);
                          });
              }));
}

function make(parent, key) {
  return Nact.spawnPersistent(key, key, undefined, Math.imul(20, Nact.messages), undefined, undefined, undefined, undefined, undefined, parent, (function (state, msg, ctx) {
                var state$1 = $$setInterval$1(state, ctx);
                if (typeof msg === "string") {
                  var persist = ctx.persist;
                  var lastMinute = state$1.lastMinute;
                  var scheduleState = state$1.scheduleState;
                  var currentMinute$1 = currentMinute(undefined);
                  var lastMinute$1 = lastMinute < 0 ? currentMinute$1 - 1 | 0 : lastMinute;
                  if (currentMinute$1 <= lastMinute$1) {
                    return Promise.resolve(state$1);
                  }
                  var scheduleState$1 = promiseReduce(Belt_Array.range(lastMinute$1, currentMinute$1), scheduleState, (function (state, minute) {
                          var state$1 = NactCron_Scheduling.update(state, NactCron_Scheduling.Time.fromDate(dateFromMinute(minute)));
                          var jobs = NactCron_Scheduling.getPendingJobs(scheduleState);
                          Belt_List.forEach(jobs, (function (param) {
                                  var match = param._2;
                                  return Nact.Operators.$less$neg$less(match[0], match[1]);
                                }));
                          return Curry._1(persist, {
                                        NAME: "ProcessedMinute",
                                        VAL: minute
                                      }).then(function (param) {
                                      return Promise.resolve(state$1);
                                    });
                        }));
                  return scheduleState$1.then(function (scheduleState) {
                              return Promise.resolve({
                                          scheduleState: scheduleState,
                                          interval: state$1.interval,
                                          lastMinute: state$1.lastMinute
                                        });
                            });
                }
                var variant = msg.NAME;
                if (variant === "StopScheduledJob") {
                  var match = msg.VAL;
                  var id = match[0];
                  var requestee = match[1];
                  var scheduleState$2 = NactCron_Scheduling.removeJob(state$1.scheduleState, id);
                  Nact.Operators.$less$neg$less(requestee, {
                        NAME: "ScheduledJobStopped",
                        VAL: id
                      });
                  return (
                            ctx.recovering ? Promise.resolve(undefined) : Curry._1(ctx.persist, {
                                    NAME: "StopScheduledJob",
                                    VAL: [
                                      id,
                                      Nact.nobody(undefined)
                                    ]
                                  })
                          ).then(function (param) {
                              return Promise.resolve({
                                          scheduleState: scheduleState$2,
                                          interval: state$1.interval,
                                          lastMinute: state$1.lastMinute
                                        });
                            });
                }
                if (variant !== "GetScheduledJob") {
                  if (variant === "GetScheduledJobs") {
                    var requestee$1 = msg.VAL;
                    Nact.Operators.$less$neg$less(requestee$1, {
                          NAME: "ScheduledJobs",
                          VAL: NactCron_Scheduling.getJobs(state$1.scheduleState)
                        });
                    return Promise.resolve(state$1);
                  } else if (variant === "ProcessedMinute") {
                    return Promise.resolve({
                                scheduleState: state$1.scheduleState,
                                interval: state$1.interval,
                                lastMinute: msg.VAL
                              });
                  } else {
                    var match$1 = msg.VAL;
                    var requestee$2 = match$1[3];
                    var actor = match$1[2];
                    var msg$1 = match$1[1];
                    var expr = match$1[0];
                    var scheduleState$3 = state$1.scheduleState;
                    var parsedExpression;
                    try {
                      parsedExpression = {
                        TAG: /* Ok */0,
                        _0: NactCron_Expression.parse(expr)
                      };
                    }
                    catch (raw_exn){
                      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                      if (exn.RE_EXN_ID === NactCron_Expression.MalformedCronExpression) {
                        parsedExpression = {
                          TAG: /* Error */1,
                          _0: {
                            NAME: "MalformedCronExpression",
                            VAL: expr
                          }
                        };
                      } else {
                        throw exn;
                      }
                    }
                    if (parsedExpression.TAG === /* Ok */0) {
                      var parsedExpr = parsedExpression._0;
                      return (
                                ctx.recovering ? Promise.resolve(undefined) : Curry._1(ctx.persist, {
                                        NAME: "StartScheduledJob",
                                        VAL: [
                                          expr,
                                          msg$1,
                                          actor,
                                          Nact.nobody(undefined)
                                        ]
                                      })
                              ).then(function (param) {
                                  var match = NactCron_Scheduling.addJob(scheduleState$3, parsedExpr, [
                                        actor,
                                        msg$1
                                      ]);
                                  Nact.Operators.$less$neg$less(requestee$2, {
                                        NAME: "ScheduledJobStarted",
                                        VAL: match[0]._0
                                      });
                                  return Promise.resolve({
                                              scheduleState: match[1],
                                              interval: state$1.interval,
                                              lastMinute: state$1.lastMinute
                                            });
                                });
                    }
                    Nact.Operators.$less$neg$less(requestee$2, parsedExpression._0);
                    return Promise.resolve(state$1);
                  }
                }
                var match$2 = msg.VAL;
                var id$1 = match$2[0];
                var requestee$3 = match$2[1];
                var job = NactCron_Scheduling.tryFindJob(state$1.scheduleState, id$1);
                if (job !== undefined) {
                  Nact.Operators.$less$neg$less(requestee$3, {
                        NAME: "FoundScheduledJob",
                        VAL: job
                      });
                } else {
                  Nact.Operators.$less$neg$less(requestee$3, {
                        NAME: "ScheduledJobNotFound",
                        VAL: id$1
                      });
                }
                return Promise.resolve(state$1);
              }), (function (param) {
                return {
                        scheduleState: NactCron_Scheduling.empty,
                        interval: undefined,
                        lastMinute: -1
                      };
              }));
}

var Scheduling;

exports.Scheduling = Scheduling;
exports.make = make;
/* Nact Not a pure module */
