// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.bs.js");
var Random = require("bs-platform/lib/js/random.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var NactCron_Expression = require("../src/NactCron_Expression.bs.js");
var NactCron_Scheduling = require("../src/NactCron_Scheduling.bs.js");

Jest.describe("update", (function (param) {
        Jest.test("The schedule state updated twice with the same time should still return the same schedule", (function (param) {
                var time = {
                  year: 2022,
                  month: 1,
                  dayOfMonth: 2,
                  dayOfWeek: 2,
                  hour: 0,
                  minute: 0,
                  daysInMonth: 31
                };
                return Jest.Expect.toHaveLength(1, Jest.Expect.expect(Belt_List.toArray(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("0 0 2 * *"), "job")[1], time), time)))));
              }));
        Jest.test("Should update schedules if the year changes", (function (param) {
                var time2 = {
                  year: 2023,
                  month: 1,
                  dayOfMonth: 2,
                  dayOfWeek: 2,
                  hour: 0,
                  minute: 0,
                  daysInMonth: 31
                };
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("* * * * * 2022"), "job")[1], NactCron_Expression.parse("* * * * * 2023"), "job");
                return Jest.Expect.toEqual({
                            hd: match[0],
                            tl: /* [] */0
                          }, Jest.Expect.expect(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], {
                                            year: 2022,
                                            month: 1,
                                            dayOfMonth: 2,
                                            dayOfWeek: 2,
                                            hour: 0,
                                            minute: 0,
                                            daysInMonth: 31
                                          }), time2))));
              }));
        Jest.test("Should update schedules if the month changes", (function (param) {
                var time2 = {
                  year: 2022,
                  month: 2,
                  dayOfMonth: 2,
                  dayOfWeek: 2,
                  hour: 0,
                  minute: 0,
                  daysInMonth: 31
                };
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("* * * JAN *"), "job")[1], NactCron_Expression.parse("* * * FEB *"), "job");
                return Jest.Expect.toEqual({
                            hd: match[0],
                            tl: /* [] */0
                          }, Jest.Expect.expect(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], {
                                            year: 2022,
                                            month: 1,
                                            dayOfMonth: 2,
                                            dayOfWeek: 2,
                                            hour: 0,
                                            minute: 0,
                                            daysInMonth: 31
                                          }), time2))));
              }));
        Jest.test("Should update schedules if the day of month changes", (function (param) {
                var time2 = {
                  year: 2022,
                  month: 1,
                  dayOfMonth: 3,
                  dayOfWeek: 3,
                  hour: 0,
                  minute: 0,
                  daysInMonth: 31
                };
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("* * 2 * *"), "job")[1], NactCron_Expression.parse("* * 3 * *"), "job");
                return Jest.Expect.toEqual({
                            hd: match[0],
                            tl: /* [] */0
                          }, Jest.Expect.expect(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], {
                                            year: 2022,
                                            month: 1,
                                            dayOfMonth: 2,
                                            dayOfWeek: 2,
                                            hour: 0,
                                            minute: 0,
                                            daysInMonth: 31
                                          }), time2))));
              }));
        Jest.test("Should update schedules if the hour changes", (function (param) {
                var time2 = {
                  year: 2022,
                  month: 1,
                  dayOfMonth: 2,
                  dayOfWeek: 2,
                  hour: 3,
                  minute: 0,
                  daysInMonth: 31
                };
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("* 2 * * *"), "job")[1], NactCron_Expression.parse("* 3 * * *"), "job");
                return Jest.Expect.toEqual({
                            hd: match[0],
                            tl: /* [] */0
                          }, Jest.Expect.expect(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], {
                                            year: 2022,
                                            month: 1,
                                            dayOfMonth: 2,
                                            dayOfWeek: 2,
                                            hour: 2,
                                            minute: 0,
                                            daysInMonth: 31
                                          }), time2))));
              }));
        return Jest.test("Should update schedules if the minute changes", (function (param) {
                      var time2 = {
                        year: 2022,
                        month: 1,
                        dayOfMonth: 2,
                        dayOfWeek: 2,
                        hour: 2,
                        minute: 1,
                        daysInMonth: 31
                      };
                      var match = NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("1 * * * *"), "job");
                      return Jest.Expect.toEqual({
                                  hd: match[0],
                                  tl: /* [] */0
                                }, Jest.Expect.expect(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], {
                                                  year: 2022,
                                                  month: 1,
                                                  dayOfMonth: 2,
                                                  dayOfWeek: 2,
                                                  hour: 2,
                                                  minute: 0,
                                                  daysInMonth: 31
                                                }), time2))));
                    }));
      }));

Jest.describe("getJobs", (function (param) {
        return Jest.test("All schedules should be returned (including non matching ones)", (function (param) {
                      return Jest.Expect.toHaveLength(2, Jest.Expect.expect(Belt_List.toArray(NactCron_Scheduling.getJobs(NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, {
                                                              year: 2022,
                                                              month: 1,
                                                              dayOfMonth: 2,
                                                              dayOfWeek: 2,
                                                              hour: 0,
                                                              minute: 0,
                                                              daysInMonth: 31
                                                            }), NactCron_Expression.parse("0 0 1 * *"), "job")[1], NactCron_Expression.parse("0 0 * * TUE"), "job2")[1]))));
                    }));
      }));

Jest.describe("tryFindJob", (function (param) {
        var initialState = NactCron_Scheduling.update(NactCron_Scheduling.empty, {
              year: 2022,
              month: 1,
              dayOfMonth: 2,
              dayOfWeek: 2,
              hour: 2,
              minute: 0,
              daysInMonth: 31
            });
        Jest.test("Trying to find an existing schedule should return Some", (function (param) {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * * * * 2023"), "job");
                var schedule = match[0];
                return Jest.Expect.toEqual(schedule, Jest.Expect.expect(NactCron_Scheduling.tryFindJob(match[1], schedule._0)));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function (param) {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * * 2 *"), "job");
                var schedule = match[0];
                return Jest.Expect.toEqual(schedule, Jest.Expect.expect(NactCron_Scheduling.tryFindJob(match[1], schedule._0)));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function (param) {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * * * 1"), "job");
                var schedule = match[0];
                return Jest.Expect.toEqual(schedule, Jest.Expect.expect(NactCron_Scheduling.tryFindJob(match[1], schedule._0)));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function (param) {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * 1 * *"), "job");
                var schedule = match[0];
                return Jest.Expect.toEqual(schedule, Jest.Expect.expect(NactCron_Scheduling.tryFindJob(match[1], schedule._0)));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function (param) {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* 3 * * *"), "job");
                var schedule = match[0];
                return Jest.Expect.toEqual(schedule, Jest.Expect.expect(NactCron_Scheduling.tryFindJob(match[1], schedule._0)));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function (param) {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("1 * * * *"), "job");
                var schedule = match[0];
                return Jest.Expect.toEqual(schedule, Jest.Expect.expect(NactCron_Scheduling.tryFindJob(match[1], schedule._0)));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function (param) {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * * * *"), "job");
                var schedule = match[0];
                return Jest.Expect.toEqual(schedule, Jest.Expect.expect(NactCron_Scheduling.tryFindJob(match[1], schedule._0)));
              }));
        return Jest.test("Trying to find a non existant schedule should return None", (function (param) {
                      var state = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("1 2 2 1 * 2022"), "job")[1];
                      return Jest.Expect.toEqual(undefined, Jest.Expect.expect(NactCron_Scheduling.tryFindJob(state, NactCron_Scheduling.ScheduleId.fromInteger(Random.$$int(1000)))));
                    }));
      }));

Jest.describe("removeJob", (function (param) {
        Jest.test("Trying to remove a job which never even existed should return successfully with the previous state", (function (param) {
                var state = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, {
                            year: 2022,
                            month: 1,
                            dayOfMonth: 2,
                            dayOfWeek: 2,
                            hour: 0,
                            minute: 0,
                            daysInMonth: 31
                          }), NactCron_Expression.parse("0 0 1 * *"), "job")[1];
                return Jest.Expect.toEqual(state, Jest.Expect.expect(NactCron_Scheduling.removeJob(state, NactCron_Scheduling.ScheduleId.fromInteger(Random.$$int(1000)))));
              }));
        var time = {
          year: 2022,
          month: 2,
          dayOfMonth: 2,
          dayOfWeek: 2,
          hour: 2,
          minute: 0,
          daysInMonth: 31
        };
        var initialState = NactCron_Scheduling.update(NactCron_Scheduling.empty, time);
        Jest.test("Removing a job should successfully remove the job", (function (param) {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * * * * 2023"), "job");
                return Jest.Expect.toEqual(initialState, Jest.Expect.expect(NactCron_Scheduling.removeJob(match[1], match[0]._0)));
              }));
        Jest.test("Removing a job should successfully remove the job", (function (param) {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * * 1 *"), "job");
                return Jest.Expect.toEqual(initialState, Jest.Expect.expect(NactCron_Scheduling.removeJob(match[1], match[0]._0)));
              }));
        Jest.test("Removing a job should successfully remove the job", (function (param) {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * * * 1"), "job");
                return Jest.Expect.toEqual(initialState, Jest.Expect.expect(NactCron_Scheduling.removeJob(match[1], match[0]._0)));
              }));
        Jest.test("Removing a job should successfully remove the job", (function (param) {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * 1 * *"), "job");
                return Jest.Expect.toEqual(initialState, Jest.Expect.expect(NactCron_Scheduling.removeJob(match[1], match[0]._0)));
              }));
        Jest.test("Removing a job should successfully remove the job", (function (param) {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* 1 * * *"), "job");
                return Jest.Expect.toEqual(initialState, Jest.Expect.expect(NactCron_Scheduling.removeJob(match[1], match[0]._0)));
              }));
        Jest.test("Removing a job should successfully remove the job", (function (param) {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("1 * * * *"), "job");
                return Jest.Expect.toEqual(initialState, Jest.Expect.expect(NactCron_Scheduling.removeJob(match[1], match[0]._0)));
              }));
        return Jest.test("Removing a job should successfully remove the job", (function (param) {
                      var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * * * *"), "job");
                      return Jest.Expect.toEqual(initialState, Jest.Expect.expect(NactCron_Scheduling.removeJob(match[1], match[0]._0)));
                    }));
      }));

Jest.describe("getPendingJobs", (function (param) {
        Jest.test("An all wildcard schedule should always be returned", (function (param) {
                return Jest.Expect.toHaveLength(1, Jest.Expect.expect(Belt_List.toArray(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, NactCron_Scheduling.Time.fromDate(new Date())), NactCron_Expression.parse("* * * * *"), "job")[1]))));
              }));
        return Jest.test("A non matching schedule should not be returned", (function (param) {
                      return Jest.Expect.toHaveLength(1, Jest.Expect.expect(Belt_List.toArray(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, {
                                                              year: 2022,
                                                              month: 1,
                                                              dayOfMonth: 2,
                                                              dayOfWeek: 2,
                                                              hour: 0,
                                                              minute: 0,
                                                              daysInMonth: 31
                                                            }), NactCron_Expression.parse("0 0 1 * *"), "job")[1], NactCron_Expression.parse("0 0 * * TUE"), "job2")[1]))));
                    }));
      }));

Jest.describe("addJob", (function (param) {
        var initialState = NactCron_Scheduling.update(NactCron_Scheduling.empty, {
              year: 2022,
              month: 1,
              dayOfMonth: 2,
              dayOfWeek: 2,
              hour: 2,
              minute: 1,
              daysInMonth: 31
            });
        return Jest.test("A new job should be sucessfully added ", (function (param) {
                      var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("10 * * * *"), "job");
                      return Jest.Expect.toEqual({
                                  hd: match[0],
                                  tl: /* [] */0
                                }, Jest.Expect.expect(NactCron_Scheduling.getJobs(match[1])));
                    }));
      }));

var Expression;

exports.Expression = Expression;
/*  Not a pure module */
