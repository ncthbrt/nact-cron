// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.bs.js");
var Nact = require("reason-nact/src/Nact.bs.js");
var Curry = require("bs-platform/lib/js/curry.js");
var NactCron = require("../src/NactCron.bs.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var MockPersistenceEngine = require("nact/test/mock-persistence-engine");

function $great$eq$great(f, g) {
  return f.then(Curry.__1(g));
}

var TimeKeeper = {};

function delay(ms) {
  return new Promise((function (resolve, param) {
                setTimeout((function (param) {
                        return resolve(undefined);
                      }), ms);
                
              }));
}

function $$return(prim) {
  return Promise.resolve(prim);
}

function reject(msg) {
  return Promise.reject({
              RE_EXN_ID: "Failure",
              _1: msg
            });
}

var passP = Promise.resolve(Jest.pass);

Jest.describe("`StartScheduledJob", (function (param) {
        Jest.testPromise("A well formed cron expression should be able to be added as a schedule in the cronActor", undefined, (function (param) {
                var system = Nact.start(undefined, Caml_option.some(new MockPersistenceEngine.MockPersistenceEngine()), undefined);
                var cronActor = NactCron.make(system, "test");
                var actor = Nact.spawnStateless(undefined, undefined, system, (function (msg, param) {
                        return Promise.resolve((console.log(msg), undefined));
                      }));
                var f = Nact.Operators.$less$question(cronActor, [
                      (function (temp) {
                          return {
                                  NAME: "StartScheduledJob",
                                  VAL: [
                                    "@daily",
                                    "hi",
                                    actor,
                                    temp
                                  ]
                                };
                        }),
                      Math.imul(500, Nact.milliseconds)
                    ]);
                return f.then(function (param) {
                            if (typeof param === "string") {
                              return Promise.reject({
                                          RE_EXN_ID: "Failure",
                                          _1: "`FunRandomPolymorphicVariant"
                                        });
                            } else if (param.NAME === "MalformedCronExpression") {
                              return Promise.reject({
                                          RE_EXN_ID: "Failure",
                                          _1: "`MalformedCronExpression"
                                        });
                            } else {
                              return passP;
                            }
                          });
              }));
        return Jest.testPromise("A malformed cron expression should  return the message `MalformedCronExpression", undefined, (function (param) {
                      var system = Nact.start(undefined, Caml_option.some(new MockPersistenceEngine.MockPersistenceEngine()), undefined);
                      var cronActor = NactCron.make(system, "test");
                      var actor = Nact.spawnStateless(undefined, undefined, system, (function (msg, param) {
                              return Promise.resolve((console.log(msg), undefined));
                            }));
                      var f = Nact.Operators.$less$question(cronActor, [
                            (function (temp) {
                                return {
                                        NAME: "StartScheduledJob",
                                        VAL: [
                                          "badbadnotgood",
                                          "hi",
                                          actor,
                                          temp
                                        ]
                                      };
                              }),
                            Math.imul(500, Nact.milliseconds)
                          ]);
                      return f.then(function (param) {
                                  if (param.NAME === "MalformedCronExpression") {
                                    return passP;
                                  } else {
                                    return Promise.reject({
                                                RE_EXN_ID: "Failure",
                                                _1: "This cron expression should not have been accepted by the actor"
                                              });
                                  }
                                });
                    }));
      }));

Jest.describe("`StopScheduledJob", (function (param) {
        Jest.testPromise("Removal should be idempotent", undefined, (function (param) {
                var system = Nact.start(undefined, Caml_option.some(new MockPersistenceEngine.MockPersistenceEngine()), undefined);
                var cronActor = NactCron.make(system, "test");
                var actor = Nact.spawnStateless(undefined, undefined, system, (function (msg, param) {
                        return Promise.resolve((console.log(msg), undefined));
                      }));
                var f = Nact.Operators.$less$question(cronActor, [
                      (function (temp) {
                          return {
                                  NAME: "StartScheduledJob",
                                  VAL: [
                                    "@daily",
                                    "hi",
                                    actor,
                                    temp
                                  ]
                                };
                        }),
                      Math.imul(500, Nact.milliseconds)
                    ]);
                var f$1 = f.then(function (param) {
                      if (param.NAME === "MalformedCronExpression") {
                        return Promise.reject({
                                    RE_EXN_ID: "Failure",
                                    _1: "`MalformedCronExpression"
                                  });
                      }
                      var id = param.VAL;
                      Nact.Operators.$less$neg$less(cronActor, {
                            NAME: "StopScheduledJob",
                            VAL: [
                              id,
                              Nact.nobody(undefined)
                            ]
                          });
                      return Nact.Operators.$less$question(cronActor, [
                                  (function (temp) {
                                      return {
                                              NAME: "StopScheduledJob",
                                              VAL: [
                                                id,
                                                temp
                                              ]
                                            };
                                    }),
                                  Math.imul(500, Nact.milliseconds)
                                ]);
                    });
                return f$1.then(function (param) {
                            return passP;
                          });
              }));
        return Jest.testPromise("A previously created job should be able to be sucessfully removed", undefined, (function (param) {
                      var system = Nact.start(undefined, Caml_option.some(new MockPersistenceEngine.MockPersistenceEngine()), undefined);
                      var cronActor = NactCron.make(system, "test");
                      var actor = Nact.spawnStateless(undefined, undefined, system, (function (msg, param) {
                              return Promise.resolve((console.log(msg), undefined));
                            }));
                      var f = Nact.Operators.$less$question(cronActor, [
                            (function (temp) {
                                return {
                                        NAME: "StartScheduledJob",
                                        VAL: [
                                          "@daily",
                                          "hi",
                                          actor,
                                          temp
                                        ]
                                      };
                              }),
                            Math.imul(500, Nact.milliseconds)
                          ]);
                      var f$1 = f.then(function (param) {
                            if (param.NAME === "MalformedCronExpression") {
                              return Promise.reject({
                                          RE_EXN_ID: "Failure",
                                          _1: "`MalformedCronExpression"
                                        });
                            }
                            var id = param.VAL;
                            return Nact.Operators.$less$question(cronActor, [
                                        (function (temp) {
                                            return {
                                                    NAME: "StopScheduledJob",
                                                    VAL: [
                                                      id,
                                                      temp
                                                    ]
                                                  };
                                          }),
                                        Math.imul(500, Nact.milliseconds)
                                      ]);
                          });
                      var f$2 = f$1.then(function (param) {
                            var id = param.VAL;
                            return Nact.Operators.$less$question(cronActor, [
                                        (function (temp) {
                                            return {
                                                    NAME: "GetScheduledJob",
                                                    VAL: [
                                                      id,
                                                      temp
                                                    ]
                                                  };
                                          }),
                                        Math.imul(500, Nact.milliseconds)
                                      ]);
                          });
                      return f$2.then(function (param) {
                                  if (param.NAME === "FoundScheduledJob") {
                                    return Promise.reject({
                                                RE_EXN_ID: "Failure",
                                                _1: "Scheduled job should have been removed"
                                              });
                                  } else {
                                    return passP;
                                  }
                                });
                    }));
      }));

Jest.describe("`GetScheduledJobs", (function (param) {
        return Jest.testPromise("Should be able to get a list of scheduled jobs", undefined, (function (param) {
                      var system = Nact.start(undefined, Caml_option.some(new MockPersistenceEngine.MockPersistenceEngine()), undefined);
                      var cronActor = NactCron.make(system, "test");
                      var actor = Nact.spawnStateless(undefined, undefined, system, (function (msg, param) {
                              return Promise.resolve((console.log(msg), undefined));
                            }));
                      Nact.Operators.$less$neg$less(cronActor, {
                            NAME: "StartScheduledJob",
                            VAL: [
                              "@daily",
                              "daily",
                              actor,
                              Nact.nobody(undefined)
                            ]
                          });
                      Nact.Operators.$less$neg$less(cronActor, {
                            NAME: "StartScheduledJob",
                            VAL: [
                              "@weekly",
                              "weekly",
                              actor,
                              Nact.nobody(undefined)
                            ]
                          });
                      Nact.Operators.$less$neg$less(cronActor, {
                            NAME: "StartScheduledJob",
                            VAL: [
                              "@monthly",
                              "monthly",
                              actor,
                              Nact.nobody(undefined)
                            ]
                          });
                      var f = Nact.Operators.$less$question(cronActor, [
                            (function (temp) {
                                return {
                                        NAME: "GetScheduledJobs",
                                        VAL: temp
                                      };
                              }),
                            Math.imul(500, Nact.milliseconds)
                          ]);
                      return f.then(function (param) {
                                  return Promise.resolve(Jest.Expect.toHaveLength(3, Jest.Expect.expect(Belt_List.toArray(param.VAL))));
                                });
                    }));
      }));

Jest.describe("`DispatchPendingJobs", (function (param) {
        
      }));

exports.$great$eq$great = $great$eq$great;
exports.TimeKeeper = TimeKeeper;
exports.delay = delay;
exports.$$return = $$return;
exports.reject = reject;
exports.passP = passP;
/* passP Not a pure module */
